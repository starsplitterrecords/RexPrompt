<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Assembler</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body {
  font-family: sans-serif;
  padding: 20px;
  margin: 0;
  max-width: 100%;
  box-sizing: border-box;
}
.container {
  max-width: 100%;
  width: 100%;
  overflow-x: hidden;
}
select, button {
  margin: 0 10px 20px 0;
}
button {
  font-size: 1.1rem;
  padding: 14px 20px;
}
pre {
  background: #eee;
  padding: 10px;
  white-space: pre-wrap;
  word-wrap: break-word;
  max-width: 100%;
  box-sizing: border-box;
}
.block {
  margin-bottom: 15px;
}
.btn-row {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 20px;
}
</style>
</head>
<body>

<div class="container">

  <h3>Assembler</h3>

  <div class="block">
    <label>Scene (recipes)</label>
    <select id="sceneSel"></select>
  </div>

  <div class="btn-row">
    <button id="buildBtn">Build</button>
    <button id="copyBtn">Copy Assembled Text</button>
    <button id="commitBtn">Commit Scene</button>
  </div>

  <pre id="out"></pre>
  <div id="manualInputs"></div>

</div>

<script>
const files = [
  "blocking.json",
  "characters.json",
  "dialogue.json",
  "direction.json",
  "factions.json",
  "lighting.json",
  "mood.json",
  "negatives.json",
  "regions.json",
  "settings.json",
  "scenes_prequel.json"
];

async function load(path) {
  const r = await fetch("data/" + path);
  if (!r.ok) throw new Error("load fail: " + path);
  return r.json();
}

function getHandle(charId, charactersJson) {
  const entry = charactersJson[charId];
  return entry ? entry.handle || entry.name || charId : charId;
}

function formatEntry(e) {
  if (typeof e === "string") return e;
  if (e.text) return e.text;
  if (e.name) return e.name;
  if (e.summary) return e.summary;
  return JSON.stringify(e);
}

function collectManual(out, store) {
  const manual = document.querySelectorAll("#manualInputs select");
  manual.forEach(sel => {
    const f = sel.dataset.file;
    const k = sel.value;
    if (!k) return;
    if (f === "dialogue.json_subtext") {
      const entry = store["dialogue.json"][k];
      if (entry && entry.subtext) {
        out.push("\n[dialogue.json_subtext:" + k + "]\n(" + entry.subtext + ")");
      }
      return;
    }
    const entry = store[f] && store[f][k];
    if (entry) {
      out.push("\n[" + f + ":" + k + "]\n" + formatEntry(entry));
    }
  });
}

async function init() {
  const sceneSel = document.getElementById("sceneSel");
  const buildBtn = document.getElementById("buildBtn");
  const copyBtn = document.getElementById("copyBtn");
  const commitBtn = document.getElementById("commitBtn");
  const outEl = document.getElementById("out");

  const store = {};
  for (const f of files) {
    store[f] = await load(f);
  }

  const scenes = store["scenes_prequel.json"];
  let sceneOrder = Object.keys(scenes);

  function sceneLabel(key) {
    const scene = scenes[key];
    if (!scene || !scene.summary) return key;
    const s = scene.summary.trim();
    const maxLen = 60;
    if (s.length <= maxLen) return key + " - " + s;
    const cut = s.lastIndexOf(" ", maxLen);
    return key + " - " + s.slice(0, cut === -1 ? maxLen : cut);
  }

  function rebuildSceneOptions() {
    sceneSel.innerHTML = "";
    sceneOrder.forEach(key => {
      const o = document.createElement("option");
      o.value = key;
      o.textContent = sceneLabel(key);
      sceneSel.appendChild(o);
    });
  }

  rebuildSceneOptions();

  function build() {
    const sceneKey = sceneSel.value;
    const scene = scenes[sceneKey];
    const out = [];

    const cameoSet = new Set();
    if (scene && scene.dialog) {
      scene.dialog.forEach(k => {
        const d = store["dialogue.json"][k];
        if (!d) return;
        const h = getHandle(d.speakerId, store["characters.json"]);
        cameoSet.add(h);
      });
    }

    cameoSet.forEach(h => out.push(h));

    if (scene) {
      out.push("\n=== SCENE: " + sceneKey + " ===");
      out.push((scene.summary || "").trim());
      out.push("10-second vertical clip. 8K modern-futuristic prestige TV style. Fictional production.");

      if (scene.setting) {
        const e = store["settings.json"][scene.setting];
        if (e) out.push("\n[SETTING]\n" + formatEntry(e));
      }
      if (scene.region) {
        const e = store["regions.json"][scene.region];
        if (e) out.push("\n[REGION]\n" + formatEntry(e));
      }
      if (scene.factions?.length) {
        out.push("\n[FACTIONS]");
        scene.factions.forEach(k => {
          const e = store["factions.json"][k];
          if (e) out.push(formatEntry(e));
        });
      }
      if (scene.characters?.length) {
        out.push("\n[CHARACTERS]");
        scene.characters.forEach(k => {
          const e = store["characters.json"][k];
          if (e) out.push(formatEntry(e));
        });
      }
      if (scene.dialog?.length) {
        out.push("\n[DIALOGUE]");
        scene.dialog.forEach(k => {
          const d = store["dialogue.json"][k];
          if (!d) return;
          const h = getHandle(d.speakerId, store["characters.json"]);
          const line = d.text || "";
          out.push(h + ' says "' + line + '"');
          if (d.subtext) out.push("  (" + d.subtext + ")");
        });
      }
      if (scene.direction?.length) {
        out.push("\n[DIRECTION]");
        scene.direction.forEach(k => {
          const e = store["direction.json"][k];
          if (e) out.push(formatEntry(e));
        });
      }

      collectManual(out, store);
    }

    outEl.textContent = out.join("\n").trim();
  }

  buildBtn.onclick = build;
  sceneSel.onchange = build;

  commitBtn.onclick = () => {
    const key = sceneSel.value;
    const i = sceneOrder.indexOf(key);
    if (i === -1) return;
    const before = sceneOrder.slice(0, i + 1);
    const after = sceneOrder.slice(i + 1);
    sceneOrder = after.concat(before);
    rebuildSceneOptions();
    sceneSel.value = sceneOrder[0];
    build();
  };

  copyBtn.onclick = async () => {
    try {
      await navigator.clipboard.writeText(outEl.textContent || "");
    } catch {}
  };

  if (sceneOrder.length) {
    sceneSel.value = sceneOrder[0];
    build();
  }
}

init().catch(err => {
  document.getElementById("out").textContent = err.message;
});
</script>

</body>
</html>
